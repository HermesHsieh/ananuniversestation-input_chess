<!doctype html>
<html lang="zh-Hant">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>象棋資料蒐集（可拖曳縮放對齊 5 ROI）</title>
    <style>
        :root {
            --ring: #111;
            --bg: #fafafa;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            font-family: system-ui, Arial;
            background: var(--bg);
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 10px 12px;
            display: flex;
            gap: 8px;
            align-items: center;
            border-bottom: 1px solid #e5e7eb;
            background: #fff;
        }

        main {
            flex: 1;
            min-height: 0;
            display: grid;
            gap: 12px;
            padding: 12px;
        }

        .stage-wrap {
            position: relative;
            width: 100%;
            height: 60vh;
            background: #ddd;
            border-radius: 12px;
            overflow: hidden;
        }

        #stage {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* 五個雙圈導引（固定在畫面座標，方便對齊） */
        .guide {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
        }

        .guide .outer {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            border: 4px solid var(--ring);
        }

        .guide .inner {
            position: absolute;
            inset: 6px;
            border-radius: 50%;
            border: 2px solid var(--ring);
        }

        .toolbar {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button,
        select {
            padding: 10px 12px;
            font-weight: 700;
            border-radius: 12px;
            border: 2px solid #111;
            background: #fff;
        }

        .roi-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
        }

        .roi-card {
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 10px;
            background: #fff;
        }

        .roi-card img {
            width: 100%;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .hint {
            color: #6b7280;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <header>
        <input id="pick" type="file" accept="image/*" capture="environment" hidden>
        <button id="pickBtn">拍照 / 選相簿</button>
        <button id="resetViewBtn" disabled>重置視圖</button>
        <button id="captureBtn" disabled>擷取 5 格</button>
        <button id="exportZipBtn" disabled>下載 ZIP</button>
        <span class="hint">單指拖曳、雙指縮放；滑鼠：拖曳 / 滾輪縮放</span>
    </header>

    <main>
        <div class="stage-wrap" id="stageWrap">
            <canvas id="stage"></canvas>
            <!-- 五個導引圈（位置由 JS 以相對百分比配置） -->
            <div class="guide" id="g1">
                <div class="outer"></div>
                <div class="inner"></div>
            </div>
            <div class="guide" id="g2">
                <div class="outer"></div>
                <div class="inner"></div>
            </div>
            <div class="guide" id="g3">
                <div class="outer"></div>
                <div class="inner"></div>
            </div>
            <div class="guide" id="g4">
                <div class="outer"></div>
                <div class="inner"></div>
            </div>
            <div class="guide" id="g5">
                <div class="outer"></div>
                <div class="inner"></div>
            </div>
        </div>

        <section id="roisSec" style="display:none">
            <h3>ROI 標記</h3>
            <div class="roi-list" id="roiList"></div>
        </section>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script>
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const wrap = document.getElementById('stageWrap');
        const canvas = document.getElementById('stage');
        const ctx = canvas.getContext('2d');
        const pick = document.getElementById('pick');
        const pickBtn = document.getElementById('pickBtn');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const captureBtn = document.getElementById('captureBtn');
        const exportZipBtn = document.getElementById('exportZipBtn');
        const roiList = document.getElementById('roiList');
        const roisSec = document.getElementById('roisSec');

        const CLASSES = ['將', '士', '象', '車', '馬', '包', '卒', '帥', '仕', '相', '俥', '傌', '炮', '兵'];

        // 五圈相對百分比（以容器寬高算），十字幾何
        const guidesPct = {
            1: { x: 50, y: 50, r: 16 },
            2: { x: 22, y: 50, r: 16 },
            3: { x: 78, y: 50, r: 16 },
            4: { x: 50, y: 26, r: 16 },
            5: { x: 50, y: 74, r: 16 },
        };

        // 視圖狀態（img -> canvas 轉換）
        let bmp = null;           // ImageBitmap
        let scale = 1;            // 當前縮放
        let minScale = 1, maxScale = 5;
        let tx = 0, ty = 0;       // 平移（canvas 像素座標）
        let isPointerDown = false;
        let pointers = new Map(); // 支援雙指
        let initDist = 0, initScale = 1, initMid = { x: 0, y: 0 };
        let roiCanvases = [];

        // 調整 canvas 實際像素大小以因應 DPR
        function resizeCanvasToDisplaySize() {
            const rect = wrap.getBoundingClientRect();
            canvas.width = Math.round(rect.width * dpr);
            canvas.height = Math.round(rect.height * dpr);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
        }

        function layoutGuides() {
            const rect = wrap.getBoundingClientRect();
            for (let i = 1; i <= 5; i++) {
                const el = document.getElementById('g' + i);
                const p = guidesPct[i];
                const rpx = Math.round((p.r / 100) * Math.min(rect.width, rect.height));
                const cx = Math.round((p.x / 100) * rect.width);
                const cy = Math.round((p.y / 100) * rect.height);
                Object.assign(el.style, {
                    left: (cx - rpx) + 'px',
                    top: (cy - rpx) + 'px',
                    width: (rpx * 2) + 'px',
                    height: (rpx * 2) + 'px'
                });
            }
        }

        // 將容器座標（CSS 像素）轉成 canvas 像素
        function toCanvasPx(pt) {
            const rect = wrap.getBoundingClientRect();
            return { x: (pt.x - rect.left) * dpr, y: (pt.y - rect.top) * dpr, r: pt.r ? pt.r * dpr : undefined };
        }
        // 由容器元素中心/半徑抓出（CSS px）
        function getGuideClient(i) {
            const g = document.getElementById('g' + i);
            const rect = g.getBoundingClientRect();
            return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2, r: rect.width / 2 };
        }

        // 視圖套用：把原圖畫到 canvas（先縮放平移，導引圈另外畫在 DOM）
        function draw() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!bmp) return;
            ctx.setTransform(scale, 0, 0, scale, tx, ty);
            ctx.imageSmoothingEnabled = true;
            ctx.drawImage(bmp, 0, 0);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        // 初始化視圖（圖片完整置中）
        function fitImage() {
            const W = canvas.width, H = canvas.height;
            const sx = W / bmp.width, sy = H / bmp.height;
            minScale = Math.min(sx, sy);
            scale = minScale;
            maxScale = minScale * 6; // 允許放大 6 倍，可依需求調整
            tx = (W - bmp.width * scale) / 2;
            ty = (H - bmp.height * scale) / 2;
        }

        // 縮放（以畫面座標的 anchor 為錨點）
        function zoomAt(canvasX, canvasY, newScale) {
            newScale = Math.max(minScale * 0.5, Math.min(maxScale, newScale));
            // 將畫面點映射到影像座標（舊）
            const imgX = (canvasX - tx) / scale;
            const imgY = (canvasY - ty) / scale;
            scale = newScale;
            // 讓該影像座標在新縮放下仍落在原 canvasX/Y
            tx = canvasX - imgX * scale;
            ty = canvasY - imgY * scale;
            draw();
        }

        // 事件：選檔
        pickBtn.onclick = () => pick.click();
        pick.onchange = async () => {
            const file = pick.files?.[0]; if (!file) return;
            bmp = await createImageBitmap(file);
            resizeCanvasToDisplaySize();
            fitImage();
            draw();
            layoutGuides();
            resetViewBtn.disabled = false;
            captureBtn.disabled = false;
        };
        window.addEventListener('resize', () => {
            if (!bmp) return;
            const rectBefore = { w: canvas.width, h: canvas.height };
            resizeCanvasToDisplaySize();
            // 重新置中（簡化：重置視圖；也可嘗試保留視窗比例換算）
            fitImage();
            draw();
            layoutGuides();
        });

        // 事件：重置視圖
        resetViewBtn.onclick = () => { if (!bmp) return; fitImage(); draw(); };

        // 指標（手指/滑鼠）拖曳/縮放
        wrap.addEventListener('pointerdown', (e) => {
            if (!bmp) return;
            wrap.setPointerCapture(e.pointerId);
            pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        });
        wrap.addEventListener('pointermove', (e) => {
            if (!bmp || !pointers.has(e.pointerId)) return;
            const prev = pointers.get(e.pointerId);
            pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

            if (pointers.size === 1) {
                // 單指拖曳
                const dx = (e.clientX - prev.x) * dpr;
                const dy = (e.clientY - prev.y) * dpr;
                tx += dx; ty += dy;
                draw();
            } else if (pointers.size === 2) {
                // 雙指縮放
                const [p1, p2] = [...pointers.values()];
                // 初次進入雙指時記錄
                if (!initDist) {
                    initDist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                    initScale = scale;
                    initMid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                } else {
                    const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                    const ratio = dist / initDist;
                    const midCanvas = toCanvasPx(initMid); // 以兩指中點為錨
                    zoomAt(midCanvas.x, midCanvas.y, initScale * ratio);
                }
            }
        });
        const endPointer = (e) => {
            pointers.delete(e.pointerId);
            if (pointers.size < 2) { initDist = 0; initScale = scale; }
        };
        wrap.addEventListener('pointerup', endPointer);
        wrap.addEventListener('pointercancel', endPointer);
        wrap.addEventListener('pointerleave', (e) => { if (pointers.has(e.pointerId)) endPointer(e); });

        // 滾輪縮放（以滑鼠位置為錨）
        wrap.addEventListener('wheel', (e) => {
            if (!bmp) return;
            e.preventDefault();
            const rect = wrap.getBoundingClientRect();
            const canvasX = (e.clientX - rect.left) * dpr;
            const canvasY = (e.clientY - rect.top) * dpr;
            const factor = Math.exp(-e.deltaY * 0.0015); // 平滑縮放
            zoomAt(canvasX, canvasY, scale * factor);
        }, { passive: false });

        // 擷取 5 ROI（用「逆變換」從原圖取像，避免畫面縮放失真）
        function cropROIFromOriginal(guideClientPx) {
            // guide 的中心/半徑（CSS px）→ canvas px
            const c = toCanvasPx(guideClientPx); // {x,y,r} in canvas pixels
            const roiCanvas = document.createElement('canvas');
            roiCanvas.width = roiCanvas.height = 224;
            const rCanvas = c.r * 0.95; // 取內圈；避免邊緣干擾，可依實測微調

            // 目標 ROI 在「原圖」座標系的矩形（source rect）
            // 對應關係： canvas = image * scale + [tx,ty]  => image = (canvas - [tx,ty]) / scale
            const srcX = ((c.x - rCanvas) - tx) / scale;
            const srcY = ((c.y - rCanvas) - ty) / scale;
            const srcW = (2 * rCanvas) / scale;
            const srcH = (2 * rCanvas) / scale;

            // 邊界裁切
            const sx = Math.max(0, Math.min(bmp.width, srcX));
            const sy = Math.max(0, Math.min(bmp.height, srcY));
            const sw = Math.max(1, Math.min(bmp.width - sx, srcW));
            const sh = Math.max(1, Math.min(bmp.height - sy, srcH));

            const octx = roiCanvas.getContext('2d');
            octx.imageSmoothingQuality = 'high';
            octx.drawImage(bmp, sx, sy, sw, sh, 0, 0, roiCanvas.width, roiCanvas.height);
            return roiCanvas;
        }

        function renderRoiList() {
            roiList.innerHTML = '';
            roiCanvases.forEach((cv, idx) => {
                const url = cv.toDataURL('image/jpeg', 0.9);
                const card = document.createElement('div');
                card.className = 'roi-card';
                card.innerHTML = `
        <img src="${url}" alt="slot${idx + 1}">
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
          <label>類別</label>
          <select data-slot="${idx + 1}">
            ${CLASSES.map(c => `<option value="${c}">${c}</option>`).join('')}
          </select>
        </div>
      `;
                roiList.appendChild(card);
            });
        }

        captureBtn.onclick = () => {
            if (!bmp) return;
            roiCanvases = [];
            for (let i = 1; i <= 5; i++) {
                const gc = getGuideClient(i);
                roiCanvases.push(cropROIFromOriginal(gc));
            }
            renderRoiList();
            roisSec.style.display = '';
            exportZipBtn.disabled = false;
        };

        exportZipBtn.onclick = async () => {
            const zip = new JSZip();
            const ts = new Date().toISOString().replace(/[:.]/g, '');
            const sels = [...roiList.querySelectorAll('select')];
            for (const sel of sels) {
                const slot = sel.dataset.slot;
                const klass = sel.value;
                const cv = roiCanvases[slot - 1];
                const blob = await new Promise(res => cv.toBlob(res, 'image/jpeg', 0.9));
                zip.file(`${klass}_slot${slot}_${ts}.jpg`, blob);
            }
            const content = await zip.generateAsync({ type: 'blob' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(content);
            a.download = `xq_dataset_${ts}.zip`;
            a.click();
        };
    </script>
</body>

</html>