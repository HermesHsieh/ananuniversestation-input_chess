<!doctype html>
<html lang="zh-Hant">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>象棋資料蒐集（可拖曳縮放對齊 5 ROI）</title>
    <style>
        :root {
            --ring: #111;
            --bg: #fafafa;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            font-family: system-ui, Arial;
            background: var(--bg);
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 10px 12px;
            display: flex;
            gap: 8px;
            align-items: center;
            border-bottom: 1px solid #e5e7eb;
            background: #fff;
        }

        main {
            flex: 1;
            min-height: 0;
            display: grid;
            gap: 12px;
            padding: 12px;
        }

        .stage-wrap {
            position: relative;
            width: 100%;
            height: 60vh;
            background: #ddd;
            border-radius: 12px;
            overflow: hidden;
        }

        #stage {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* 五個雙圈導引（固定在畫面座標，方便對齊） */
        .guide {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
        }

        .guide .outer {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            border: 4px solid var(--ring);
        }

        .guide .inner {
            position: absolute;
            inset: 6px;
            border-radius: 50%;
            border: 2px solid var(--ring);
        }

        .toolbar {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button,
        select {
            padding: 10px 12px;
            font-weight: 700;
            border-radius: 12px;
            border: 2px solid #111;
            background: #fff;
        }

        .roi-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
        }

        .roi-card {
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 10px;
            background: #fff;
        }

        .roi-card img {
            width: 100%;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .hint {
            color: #6b7280;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <header>
        <input id="pick" type="file" accept="image/*" capture="environment" hidden>
        <button id="pickBtn">拍照 / 選相簿</button>
        <button id="resetViewBtn" disabled>重置視圖</button>
        <button id="captureBtn" disabled>擷取 5 格</button>
        <button id="exportZipBtn" disabled>下載 ZIP</button>
        <span class="hint">單指拖曳、雙指縮放；滑鼠：拖曳 / 滾輪縮放</span>
    </header>

    <main>
        <div class="stage-wrap" id="stageWrap">
            <canvas id="stage"></canvas>
            <!-- 五個導引圈（位置由 JS 以相對百分比配置） -->
            <div class="guide" id="g1">
                <div class="outer"></div>
                <div class="inner"></div>
            </div>
            <div class="guide" id="g2">
                <div class="outer"></div>
                <div class="inner"></div>
            </div>
            <div class="guide" id="g3">
                <div class="outer"></div>
                <div class="inner"></div>
            </div>
            <div class="guide" id="g4">
                <div class="outer"></div>
                <div class="inner"></div>
            </div>
            <div class="guide" id="g5">
                <div class="outer"></div>
                <div class="inner"></div>
            </div>
        </div>

        <section id="roisSec" style="display:none">
            <h3>ROI 標記</h3>
            <div class="roi-list" id="roiList"></div>
        </section>

        <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap;">
            <button id="addSamplesBtn">加入 5 張為樣本</button>
            <button id="classifyBtn">分類 5 張</button>
        </div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script>
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const wrap = document.getElementById('stageWrap');
        const canvas = document.getElementById('stage');
        const ctx = canvas.getContext('2d');
        const pick = document.getElementById('pick');
        const pickBtn = document.getElementById('pickBtn');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const captureBtn = document.getElementById('captureBtn');
        const exportZipBtn = document.getElementById('exportZipBtn');
        const roiList = document.getElementById('roiList');
        const roisSec = document.getElementById('roisSec');

        const CLASSES = ['將', '士', '象', '車', '馬', '包', '卒', '帥', '仕', '相', '俥', '傌', '炮', '兵'];

        // 五圈相對百分比（以容器寬高算），十字幾何
        const guidesPct = {
            1: { x: 50, y: 50, r: 14 },
            2: { x: 22, y: 50, r: 14 },
            3: { x: 78, y: 50, r: 14 },
            4: { x: 50, y: 26, r: 14 },
            5: { x: 50, y: 74, r: 14 },
        };

        // 視圖狀態（img -> canvas 轉換）
        let bmp = null;           // ImageBitmap
        let scale = 1;            // 當前縮放
        let minScale = 1, maxScale = 5;
        let tx = 0, ty = 0;       // 平移（canvas 像素座標）
        let isPointerDown = false;
        let pointers = new Map(); // 支援雙指
        let initDist = 0, initScale = 1, initMid = { x: 0, y: 0 };
        let roiCanvases = [];

        // 調整 canvas 實際像素大小以因應 DPR
        function resizeCanvasToDisplaySize() {
            const rect = wrap.getBoundingClientRect();
            canvas.width = Math.round(rect.width * dpr);
            canvas.height = Math.round(rect.height * dpr);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
        }

        function layoutGuides() {
            const rect = wrap.getBoundingClientRect();
            for (let i = 1; i <= 5; i++) {
                const el = document.getElementById('g' + i);
                const p = guidesPct[i];
                const rpx = Math.round((p.r / 100) * Math.min(rect.width, rect.height));
                const cx = Math.round((p.x / 100) * rect.width);
                const cy = Math.round((p.y / 100) * rect.height);
                Object.assign(el.style, {
                    left: (cx - rpx) + 'px',
                    top: (cy - rpx) + 'px',
                    width: (rpx * 2) + 'px',
                    height: (rpx * 2) + 'px'
                });
            }
        }

        // 將容器座標（CSS 像素）轉成 canvas 像素
        function toCanvasPx(pt) {
            const rect = wrap.getBoundingClientRect();
            return { x: (pt.x - rect.left) * dpr, y: (pt.y - rect.top) * dpr, r: pt.r ? pt.r * dpr : undefined };
        }
        // 由容器元素中心/半徑抓出（CSS px）
        function getGuideClient(i) {
            const g = document.getElementById('g' + i);
            const rect = g.getBoundingClientRect();
            return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2, r: rect.width / 2 };
        }

        // 視圖套用：把原圖畫到 canvas（先縮放平移，導引圈另外畫在 DOM）
        function draw() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!bmp) return;
            ctx.setTransform(scale, 0, 0, scale, tx, ty);
            ctx.imageSmoothingEnabled = true;
            ctx.drawImage(bmp, 0, 0);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        // 初始化視圖（圖片完整置中）
        function fitImage() {
            const W = canvas.width, H = canvas.height;
            const sx = W / bmp.width, sy = H / bmp.height;
            minScale = Math.min(sx, sy);
            scale = minScale;
            maxScale = minScale * 6; // 允許放大 6 倍，可依需求調整
            tx = (W - bmp.width * scale) / 2;
            ty = (H - bmp.height * scale) / 2;
        }

        // 縮放（以畫面座標的 anchor 為錨點）
        function zoomAt(canvasX, canvasY, newScale) {
            newScale = Math.max(minScale * 0.5, Math.min(maxScale, newScale));
            // 將畫面點映射到影像座標（舊）
            const imgX = (canvasX - tx) / scale;
            const imgY = (canvasY - ty) / scale;
            scale = newScale;
            // 讓該影像座標在新縮放下仍落在原 canvasX/Y
            tx = canvasX - imgX * scale;
            ty = canvasY - imgY * scale;
            draw();
        }

        // 事件：選檔
        pickBtn.onclick = () => pick.click();
        pick.onchange = async () => {
            const file = pick.files?.[0]; if (!file) return;
            bmp = await createImageBitmap(file);
            resizeCanvasToDisplaySize();
            fitImage();
            draw();
            layoutGuides();
            resetViewBtn.disabled = false;
            captureBtn.disabled = false;
        };
        window.addEventListener('resize', () => {
            if (!bmp) return;
            const rectBefore = { w: canvas.width, h: canvas.height };
            resizeCanvasToDisplaySize();
            // 重新置中（簡化：重置視圖；也可嘗試保留視窗比例換算）
            fitImage();
            draw();
            layoutGuides();
        });

        // 事件：重置視圖
        resetViewBtn.onclick = () => { if (!bmp) return; fitImage(); draw(); };

        // 指標（手指/滑鼠）拖曳/縮放
        wrap.addEventListener('pointerdown', (e) => {
            if (!bmp) return;
            wrap.setPointerCapture(e.pointerId);
            pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        });
        wrap.addEventListener('pointermove', (e) => {
            if (!bmp || !pointers.has(e.pointerId)) return;
            const prev = pointers.get(e.pointerId);
            pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

            if (pointers.size === 1) {
                // 單指拖曳
                const dx = (e.clientX - prev.x) * dpr;
                const dy = (e.clientY - prev.y) * dpr;
                tx += dx; ty += dy;
                draw();
            } else if (pointers.size === 2) {
                // 雙指縮放
                const [p1, p2] = [...pointers.values()];
                // 初次進入雙指時記錄
                if (!initDist) {
                    initDist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                    initScale = scale;
                    initMid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                } else {
                    const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                    const ratio = dist / initDist;
                    const midCanvas = toCanvasPx(initMid); // 以兩指中點為錨
                    zoomAt(midCanvas.x, midCanvas.y, initScale * ratio);
                }
            }
        });
        const endPointer = (e) => {
            pointers.delete(e.pointerId);
            if (pointers.size < 2) { initDist = 0; initScale = scale; }
        };
        wrap.addEventListener('pointerup', endPointer);
        wrap.addEventListener('pointercancel', endPointer);
        wrap.addEventListener('pointerleave', (e) => { if (pointers.has(e.pointerId)) endPointer(e); });

        // 滾輪縮放（以滑鼠位置為錨）
        wrap.addEventListener('wheel', (e) => {
            if (!bmp) return;
            e.preventDefault();
            const rect = wrap.getBoundingClientRect();
            const canvasX = (e.clientX - rect.left) * dpr;
            const canvasY = (e.clientY - rect.top) * dpr;
            const factor = Math.exp(-e.deltaY * 0.0015); // 平滑縮放
            zoomAt(canvasX, canvasY, scale * factor);
        }, { passive: false });

        // 擷取 5 ROI（用「逆變換」從原圖取像，避免畫面縮放失真）
        function cropROIFromOriginal(guideClientPx) {
            // guide 的中心/半徑（CSS px）→ canvas px
            const c = toCanvasPx(guideClientPx); // {x,y,r} in canvas pixels
            const roiCanvas = document.createElement('canvas');
            roiCanvas.width = roiCanvas.height = 224;
            const rCanvas = c.r * 0.95; // 取內圈；避免邊緣干擾，可依實測微調

            // 目標 ROI 在「原圖」座標系的矩形（source rect）
            // 對應關係： canvas = image * scale + [tx,ty]  => image = (canvas - [tx,ty]) / scale
            const srcX = ((c.x - rCanvas) - tx) / scale;
            const srcY = ((c.y - rCanvas) - ty) / scale;
            const srcW = (2 * rCanvas) / scale;
            const srcH = (2 * rCanvas) / scale;

            // 邊界裁切
            const sx = Math.max(0, Math.min(bmp.width, srcX));
            const sy = Math.max(0, Math.min(bmp.height, srcY));
            const sw = Math.max(1, Math.min(bmp.width - sx, srcW));
            const sh = Math.max(1, Math.min(bmp.height - sy, srcH));

            const octx = roiCanvas.getContext('2d');
            octx.imageSmoothingQuality = 'high';
            octx.drawImage(bmp, sx, sy, sw, sh, 0, 0, roiCanvas.width, roiCanvas.height);
            return roiCanvas;
        }

        function renderRoiList() {
            roiList.innerHTML = '';
            roiCanvases.forEach((cv, idx) => {
                const url = cv.toDataURL('image/jpeg', 0.9);
                const card = document.createElement('div');
                card.className = 'roi-card';
                card.innerHTML = `
        <img src="${url}" alt="slot${idx + 1}">
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
          <label>類別</label>
          <select data-slot="${idx + 1}">
            ${CLASSES.map(c => `<option value="${c}">${c}</option>`).join('')}
          </select>
        </div>
      `;
                roiList.appendChild(card);
            });
        }

        captureBtn.onclick = () => {
            if (!bmp) return;
            roiCanvases = [];
            for (let i = 1; i <= 5; i++) {
                const gc = getGuideClient(i);
                roiCanvases.push(cropROIFromOriginal(gc));
            }
            renderRoiList();
            roisSec.style.display = '';
            exportZipBtn.disabled = false;

            // ★★★ 新增這一行：把 5 張 ROI 給分類器
            currentRois = roiCanvases;
        };

        exportZipBtn.onclick = async () => {
            const zip = new JSZip();
            const ts = new Date().toISOString().replace(/[:.]/g, '');
            const sels = [...roiList.querySelectorAll('select')];
            for (const sel of sels) {
                const slot = sel.dataset.slot;
                const klass = sel.value;
                const cv = roiCanvases[slot - 1];
                const blob = await new Promise(res => cv.toBlob(res, 'image/jpeg', 0.9));
                zip.file(`${klass}_slot${slot}_${ts}.jpg`, blob);
            }
            const content = await zip.generateAsync({ type: 'blob' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(content);
            a.download = `xq_dataset_${ts}.zip`;
            a.click();
        };

        document.getElementById('addSamplesBtn').onclick = async () => {
            await addAllFiveAsSamplesUsingSelections();  // 會讀取每張 ROI 卡片旁的 <select>
            alert('已加入樣本/更新質心');
        };

        document.getElementById('classifyBtn').onclick = async () => {
            if (!currentRois || currentRois.length !== 5) {
                alert('請先擷取 5 張 ROI'); return;
            }
            const res = await classifyFiveRois(currentRois);
            console.table(res);
            // 你也可以把結果回填到畫面上：
            // 例如把每張 ROI 卡片 title 改成 `label (score)`
            const cards = document.querySelectorAll('.roi-card');
            res.forEach((r, i) => {
                const title = cards[i].querySelector('img');
                title.alt = `${r.label} (${r.score})`;
                cards[i].querySelector('select').value = r.label; // 低信心時可手動改
            });
        };

    </script>

    <!-- 放在 collect.html 最後、</body> 之前 -->
    <script src="https://docs.opencv.org/4.x/opencv.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2"></script>

    <script>
        // =========================
        //  參數與類別
        // =========================
        const CLASS_14 = ['將', '士', '象', '車', '馬', '包', '卒', '帥', '仕', '相', '俥', '傌', '炮', '兵'];
        let mobileModel = null; // MobileNet
        const FEATURE_LAYER = 'global_average'; // 輕量/穩定

        // 以「最近質心」做小分類器：label -> {centroid:Tensor1D, count:int}
        const protoStore = new Map();

        // 你手上的 5 個 ROI canvas（外部丟進來）
        let currentRois = []; // [Canvas, Canvas, ...] 共 5 個

        // =========================
        //  載入 MobileNet（一次）
        // =========================
        async function loadMobileNetOnce() {
            if (mobileModel) return mobileModel;
            mobileModel = await mobilenet.load({ version: 2, alpha: 0.5 });
            console.log('MobileNet loaded');
            return mobileModel;
        }

        // =========================
        //  顏色：紅/黑 判定（ROI -> boolean）
        //  小技巧：統計紅色像素比例（H 在 0–10 或 170–179）
        // =========================
        function isRedPieceCanvas(canvas) {
            // 用原生 API 做 HSV 估計（快速版）；要更穩可改用 OpenCV
            const ctx = canvas.getContext('2d');
            const { width: w, height: h } = canvas;
            const img = ctx.getImageData(0, 0, w, h).data;
            let redCount = 0, total = 0;
            for (let i = 0; i < img.length; i += 4) {
                const r = img[i], g = img[i + 1], b = img[i + 2], a = img[i + 3];
                if (a < 10) continue;
                // 粗轉 HSV：這裡用近似演算法；為穩定可換 OpenCV HSV
                const mx = Math.max(r, g, b), mn = Math.min(r, g, b);
                const c = mx - mn; const v = mx / 255;
                let hdeg = 0;
                if (c === 0) hdeg = 0;
                else if (mx === r) hdeg = ((g - b) / c) % 6 * 60;
                else if (mx === g) hdeg = ((b - r) / c + 2) * 60;
                else hdeg = ((r - g) / c + 4) * 60;
                if (hdeg < 0) hdeg += 360;
                // 紅色區域粗判
                const isRedHue = (hdeg <= 12) || (hdeg >= 348);
                if (isRedHue && v > 0.2) redCount++;
                total++;
            }
            const ratio = redCount / Math.max(1, total);
            return ratio > 0.04; // 視現場微調
        }

        // =========================
        //  （可選）OpenCV 前處理：產生「去邊的字形」debug 圖
        //  實際丟 TF.js 我們用原圖（224×224，歸一化到 [-1,1]）
        //  這個 glyph 可用來 debug 或做模板法備援
        // =========================
        function opencvGlyph(canvasIn) {
            const src = cv.imread(canvasIn);               // RGBA
            const gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            const bin = new cv.Mat();
            cv.adaptiveThreshold(gray, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C,
                cv.THRESH_BINARY_INV, 25, 10);
            const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
            cv.morphologyEx(bin, bin, cv.MORPH_CLOSE, kernel);

            // 內圈遮罩（避免外框干擾）
            const mask = new cv.Mat.zeros(bin.rows, bin.cols, cv.CV_8UC1);
            const center = new cv.Point(bin.cols / 2, bin.rows / 2);
            const radius = Math.min(bin.cols, bin.rows) * 0.42;
            cv.circle(mask, center, radius, new cv.Scalar(255), -1);
            const glyph = new cv.Mat(); cv.bitwise_and(bin, mask, glyph);

            const out = document.createElement('canvas');
            cv.imshow(out, glyph);

            // 釋放
            [src, gray, bin, kernel, mask, glyph].forEach(m => m.delete());
            return out;
        }

        // =========================
        //  影像 -> Tensor（TF.js，給 MobileNet 用）
        //  - 將 ROI 畫到 224×224
        //  - 正規化到 [-1,1]
        // =========================
        function roiToTensor(canvasIn) {
            const S = 224;
            const tmp = document.createElement('canvas');
            tmp.width = tmp.height = S;
            const tctx = tmp.getContext('2d');
            tctx.drawImage(canvasIn, 0, 0, S, S);

            return tf.tidy(() => {
                const t = tf.browser.fromPixels(tmp).toFloat();
                // [-1,1]
                return t.div(127.5).sub(1).expandDims(0); // [1,224,224,3]
            });
        }

        // =========================
        //  取特徵向量（MobileNet global_average）
        // =========================
        async function embed(canvasIn) {
            await loadMobileNetOnce();
            const input = roiToTensor(canvasIn);
            const feat = mobileModel.infer(input, FEATURE_LAYER); // [1,depth]
            input.dispose();
            return feat.squeeze(); // [depth]
        }

        // =========================
        //  新增樣本到「最近質心」分類器
        //  多次加入同一類，會自動更新質心
        // =========================
        async function addPrototypeSample(label, roiCanvas) {
            const f = await embed(roiCanvas); // Tensor1D
            let rec = protoStore.get(label);
            if (!rec) rec = { sum: null, count: 0, centroid: null };
            // sum = sum + f
            if (!rec.sum) rec.sum = f.clone();
            else {
                const old = rec.sum; rec.sum = tf.tidy(() => tf.add(old, f)); old.dispose();
            }
            rec.count += 1;
            // centroid = sum / count
            if (rec.centroid) rec.centroid.dispose();
            rec.centroid = tf.tidy(() => tf.div(rec.sum, rec.count));
            protoStore.set(label, rec);
            f.dispose();
            console.log(`[Prototype] ${label} count=${rec.count}`);
        }

        // =========================
        //  分類：與所有質心做 cosine 相似度，回傳 Top-1
        // =========================
        async function classifyRoi(roiCanvas) {
            if (protoStore.size === 0) throw new Error('尚未建立任何樣本/質心');
            const f = await embed(roiCanvas); // [d]
            let best = { label: null, score: -1 };
            // normalize f
            const fN = tf.tidy(() => {
                const n = tf.norm(f);
                return tf.div(f, n.add(1e-8));
            });
            for (const [label, rec] of protoStore) {
                const cN = tf.tidy(() => {
                    const n = tf.norm(rec.centroid);
                    return tf.div(rec.centroid, n.add(1e-8));
                });
                const sim = await tf.tidy(() => tf.sum(tf.mul(fN, cN))).data();
                if (sim[0] > best.score) best = { label, score: sim[0] };
                cN.dispose();
            }
            f.dispose(); fN.dispose();
            return best; // {label:'車'(功能名或最終名), score: 0.x}
        }

        // =========================
        //  輔助：把「功能名 + 顏色」轉成最終字
        //  方案1：直接用 14 類（建議）；
        //  方案2：若你先用 7 類功能（車/馬/包/卒 + 四尊），就用 isRed 轉字
        // =========================
        function toFinalLabel(class14 /* '車'...'兵' */, isRed) {
            // 若你已使用 14 類分類，直接回傳 class14 即可
            return class14;

            // 如果你先分類成「功能名」再轉，可改用下列邏輯：
            // const map = { '車': ['車','俥'], '馬':['馬','傌'], '包':['包','炮'], '卒':['卒','兵'] };
            // if (map[class14]) return isRed ? map[class14][1] : map[class14][0];
            // return class14;
        }

        // =========================
        //  一次分類 5 個 ROI（回傳陣列與信心）
        // =========================
        async function classifyFiveRois(roiCanvases) {
            const results = [];
            for (let i = 0; i < roiCanvases.length; i++) {
                const roi = roiCanvases[i];
                const red = isRedPieceCanvas(roi);
                const pred = await classifyRoi(roi); // {label, score}
                const final = toFinalLabel(pred.label, red);
                results.push({ slot: i + 1, label: final, score: Number(pred.score.toFixed(3)), isRed: red });
            }
            return results;
        }

        // ======== 你可以用的「上層觸發」範例 ========
        // 假設你頁面裡：
        // 1) 有 5 個 ROI canvas（已經擷取好了），放到 currentRois
        // 2) 每一格旁邊有一個 <select> 讓你選 14 類，點「加入樣本」時呼叫下列函式

        async function addAllFiveAsSamplesUsingSelections() {
            // 例如你在 ROI 清單每卡片有 <select data-slot="1">...
            const sels = document.querySelectorAll('.roi-card select');
            for (const sel of sels) {
                const slot = Number(sel.dataset.slot);
                const label = sel.value; // 14 類之一
                await addPrototypeSample(label, currentRois[slot - 1]);
            }
            alert('已加入 5 筆樣本/更新質心');
        }

        async function runClassifyCurrentRois() {
            const res = await classifyFiveRois(currentRois);
            console.table(res);
            // 你也可以把結果回填到 UI
        }

        // （可選）顯示 OpenCV 二值化 Glyph 做 debug
        function showGlyphDebug(idx /* 1..5 */) {
            const g = opencvGlyph(currentRois[idx - 1]);
            document.body.append(g); // 或放到你指定的 debug 區域
        }

        // （可選）匯出/載入質心（讓你保存目前小模型）
        function exportCentroidsJson() {
            const out = {};
            for (const [label, rec] of protoStore) {
                out[label] = Array.from(rec.centroid.dataSync());
            }
            const blob = new Blob([JSON.stringify(out)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'xq_centroids.json';
            a.click();
        }
        async function importCentroidsJson(file) {
            const text = await file.text();
            const obj = JSON.parse(text);
            protoStore.clear();
            for (const label of Object.keys(obj)) {
                const v = tf.tensor1d(obj[label]);
                protoStore.set(label, { sum: v.clone(), count: 1, centroid: v });
            }
            alert('已載入質心');
        }
    </script>

</body>

</html>