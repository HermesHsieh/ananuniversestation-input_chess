<!doctype html>
<html lang="zh-Hant">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>象棋卜卦 - 安安宇宙站</title>
  <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
  <style>
    :root {
      --red: #d32f2f;
      --black: #111;
      --bg: #F6F7FB;
      --card: #fff;
      --border: #e5e7eb;
      --accent: #2563eb;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", sans-serif;
      background: var(--bg);
      color: #111;
    }

    .wrap {
      max-width: 480px;
      margin: 0 auto;
      padding: 12px 12px 28px;
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .title {
      font-size: 18px;
      font-weight: 700;
    }

    .bar-actions {
      display: flex;
      gap: 8px;
    }

    .ghost {
      background: transparent;
      border: 1px solid var(--border);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 14px;
    }

    .ghost:active {
      opacity: .7;
    }

    .status {
      margin: 6px 0 10px;
      font-size: 12px;
      color: #666;
      text-align: center;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, .04);
    }

    .card-title {
      font-size: 16px;
      font-weight: 700;
      text-align: center;
      margin-bottom: 8px;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 14px;
      margin-top: 6px;
    }

    .cell {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      border: 2px dashed var(--border);
      border-radius: 9999px;
      background: #fff;
      aspect-ratio: 1/1;
      min-width: 72px;
      min-height: 72px;
      user-select: none;
      cursor: pointer;
      font-size: 36px;
      /* 放大棋字 */
    }

    .cell.red {
      color: var(--red);
    }

    .cell.black {
      color: var(--black);
    }

    .cell.selected {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, .12);
    }

    .poslabel {
      font-size: 12px;
      color: #999;
      margin-top: 2px;
    }

    .hint {
      font-size: 12px;
      color: #666;
      text-align: center;
      margin: 8px 0 0;
    }

    .hint-version {
      font-size: 8px;
      color: #666;
      text-align: center;
      margin: 8px 0 0;
    }

    .controls {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin: 12px 0 8px;
      flex-wrap: wrap;
    }

    .btn {
      border: 0;
      border-radius: 12px;
      padding: 12px 16px;
      font-size: 16px;
    }

    .btn-primary {
      background: #111;
      color: #fff;
    }

    .btn-secondary {
      background: #f3f4f6;
      color: #111;
      border: 1px solid var(--border);
    }

    .pieces {
      margin-top: 10px;
    }

    .row {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 8px;
    }

    .piece-btn {
      border: 1px solid var(--border);
      background: #fff;
      border-radius: 12px;
      padding: 12px 0;
      font-size: 18px;
      text-align: center;
    }

    .piece-btn:active {
      transform: scale(.98);
    }

    .piece-btn.red {
      color: var(--red);
    }

    .piece-btn.black {
      color: var(--black);
    }

    .footer-pad {
      height: 8px;
    }

    .ver-badge {
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      color: #6b7280;
      background: #fff;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">單卦</div>
      <div class="bar-actions">
        <button class="ghost" id="askBtn">輸入問題</button>
        <button class="ghost" id="reloadBtn">Reload</button>
      </div>
    </div>

    <div id="status" class="status">初始化中…</div>


    <div class="card">
      <div id="cardTitle" class="card-title"></div>

      <!-- 九宮格（上：4 / 中：2 1 3 / 下：5） -->
      <div class="grid" aria-label="十字九宮格">
        <div></div>
        <div class="cell" id="pos4"><span>4</span>
          <div class="poslabel">↑ 點選以鎖定</div>
        </div>
        <div></div>

        <div class="cell" id="pos2"><span>2</span>
          <div class="poslabel">←</div>
        </div>
        <div class="cell" id="pos1"><span>1</span>
          <div class="poslabel">中心</div>
        </div>
        <div class="cell" id="pos3"><span>3</span>
          <div class="poslabel">→</div>
        </div>

        <div></div>
        <div class="cell" id="pos5"><span>5</span>
          <div class="poslabel">↓</div>
        </div>
        <div></div>
      </div>

      <div class="controls">
        <button class="btn btn-secondary" id="randomBtn">隨機</button>
        <button class="btn btn-primary" id="sendBtn">送出</button>
        <button class="btn btn-secondary" id="clearBtn">清除</button>
      </div>

      <div class="hint" style="text-align: left;">點選下方棋子，系統會依序放入：1 → 2 → 3 → 4 → 5</div>
      <div class="hint" style="text-align: left;">點選「指定位置」→ 再點下方棋子</div>
      <div class="hint-box" style="display: flex; justify-content: space-between; align-items: center;">
        <div id="draw-mode" class="hint-version" style="text-align: left;">
          輸入方式：手動
        </div>
        <div class="hint-version" id="ver" style="text-align: right;">
        </div>
      </div>

    </div>

    <!-- 棋子選擇（黑在上、紅在下） -->
    <div class="pieces">
      <div class="row" style="margin-bottom:8px">
        <!-- 黑國：將 士 象 車 馬 包 卒 -->
        <button class="piece-btn black" data-piece="將">將</button>
        <button class="piece-btn black" data-piece="士">士</button>
        <button class="piece-btn black" data-piece="象">象</button>
        <button class="piece-btn black" data-piece="車">車</button>
        <button class="piece-btn black" data-piece="馬">馬</button>
        <button class="piece-btn black" data-piece="包">包</button>
        <button class="piece-btn black" data-piece="卒">卒</button>
      </div>
      <div class="row">
        <!-- 紅國：帥 仕 相 俥 傌 炮 兵 -->
        <button class="piece-btn red" data-piece="帥">帥</button>
        <button class="piece-btn red" data-piece="仕">仕</button>
        <button class="piece-btn red" data-piece="相">相</button>
        <button class="piece-btn red" data-piece="俥">俥</button>
        <button class="piece-btn red" data-piece="傌">傌</button>
        <button class="piece-btn red" data-piece="炮">炮</button>
        <button class="piece-btn red" data-piece="兵">兵</button>
      </div>
      <div class="footer-pad"></div>
    </div>
  </div>

  <script>
    /** ******************************
    *  🔧 在這裡換你的 LIFF ID & 版本
    *********************************/
    const LIFF_ID = "2007906926-NZW6EQ7P";
    const APP_VERSION = "v1.0.35";

    /** ******************************
    *  🧰 全套 32 枚牌堆（抽過即移除）
    *********************************/
    // 以整副棋的數量建立完整牌堆
    const FULL_DECK_COUNTS = {
      "帥": 1, "仕": 2, "相": 2, "俥": 2, "傌": 2, "炮": 2, "兵": 5,
      "將": 1, "士": 2, "象": 2, "車": 2, "馬": 2, "包": 2, "卒": 5
    };
    // 依數量展開成陣列（32 枚）
    function makeFullDeck() {
      const arr = [];
      Object.entries(FULL_DECK_COUNTS).forEach(([type, n]) => {
        for (let i = 0; i < n; i++) arr.push(type);
      });
      return arr;
    }
    // 目前牌堆（null 表示尚未建立或已重置）
    let deck = null;

    // 需求：第一次按「隨機」或清空後才建立牌堆
    function ensureDeck() {
      if (!deck || deck.length === 0) deck = makeFullDeck();
      return deck;
    }
    // 從牌堆隨機抽 1 枚（會移除該枚）
    function drawFromDeck() {
      ensureDeck();
      if (deck.length === 0) return null;
      const idx = Math.floor(Math.random() * deck.length);
      const [picked] = deck.splice(idx, 1);
      return picked; // 回傳棋種字元
    }

    // 輸入方式（手動 / 隨機）
    let drawMode = "手動"; // 預設手動
    function setDrawMode(mode) {
      drawMode = mode;
      const dm = document.getElementById("draw-mode");
      if (dm) dm.textContent = `輸入方式：${drawMode}`;
    }

    // ====== 狀態與工具 ======
    const $ = (id) => document.getElementById(id);
    const posEls = { 1: $("pos1"), 2: $("pos2"), 3: $("pos3"), 4: $("pos4"), 5: $("pos5") };
    const statusEl = $("status");
    const titleEl = $("cardTitle");

    // 目前 5 格內容：{ type, color } 或 null
    const picks = { 1: null, 2: null, 3: null, 4: null, 5: null };
    let selectedPos = null; // 定位模式：使用者選的目標位置

    const RED_SET = new Set(["帥", "仕", "相", "俥", "傌", "炮", "兵"]);
    const BLACK_SET = new Set(["將", "士", "象", "車", "馬", "包", "卒"]);

    // 整副棋上限
    const PIECE_LIMITS = {
      "帥": 1, "仕": 2, "相": 2, "俥": 2, "傌": 2, "炮": 2, "兵": 5,
      "將": 1, "士": 2, "象": 2, "車": 2, "馬": 2, "包": 2, "卒": 5
    };

    function pieceColorOf(type) {
      if (RED_SET.has(type)) return "red";
      if (BLACK_SET.has(type)) return "black";
      return null;
    }
    function firstEmptyPos() {
      for (let i = 1; i <= 5; i++) if (!picks[i]) return i;
      return null;
    }
    function countUsed(type) {
      let c = 0;
      for (let i = 1; i <= 5; i++) if (picks[i]?.type === type) c++;
      return c;
    }
    function canPlace(type, pos) {
      const limit = PIECE_LIMITS[type] ?? 0;
      const used = countUsed(type);
      const currentTypeAtPos = picks[pos]?.type || null;
      if (currentTypeAtPos === type) return true; // 覆蓋同種不增加用量
      return used < limit;
    }

    function render() {
      for (let i = 1; i <= 5; i++) {
        const el = posEls[i];
        el.classList.remove("red", "black", "selected");
        if (picks[i]) {
          el.innerHTML = `<span>${picks[i].type}</span><div class="poslabel">${i}</div>`;
          el.classList.add(picks[i].color === "red" ? "red" : "black");
        } else {
          const dir = i === 1 ? "中心" : i === 2 ? "←" : i === 3 ? "→" : i === 4 ? "↑" : "↓";
          el.innerHTML = `<span>${i}</span><div class="poslabel">${dir}</div>`;
        }
        if (selectedPos === i) el.classList.add("selected");
      }
    }

    function setSelected(pos) {
      selectedPos = (selectedPos === pos ? null : pos);
      render();
    }

    function addPiece(type) {
      setDrawMode("手動"); // ← 使用者點底部棋子視為手動
      const color = pieceColorOf(type);
      if (!color) return;

      const pos = selectedPos || firstEmptyPos();
      if (!pos) { alert("已放滿 5 格；若要重選，請按「清除」。"); return; }

      if (!canPlace(type, pos)) {
        const remain = (PIECE_LIMITS[type] - countUsed(type));
        alert(`「${type}」可用數量不足（剩餘 ${Math.max(0, remain)}）`);
        return;
      }

      picks[pos] = { type, color };
      const next = firstEmptyPos();
      selectedPos = next; // 若滿格會是 null
      render();
    }

    function clearAll(resetMode = true, resetDeck = true) {
      for (let i = 1; i <= 5; i++) picks[i] = null;
      selectedPos = null;
      if (resetMode) setDrawMode("手動"); // 清空後回到手動（可關閉）
      if (resetDeck) deck = null;        // ★ 清空時也重置牌堆（回到 32 枚）
      render();
    }

    function hardReload() {
      const base = location.origin + location.pathname;
      location.replace(base + "?t=" + Date.now()); // 破快取
    }

    function promptQuestion() {
      const t = prompt("請輸入你的卜卦問題：", titleEl.textContent || "");
      if (t && t.trim()) titleEl.textContent = t.trim();
    }

    // ====== 隨機 5 顆（遵守每種上限） ======
    function randomFillAll() {
      // 先清空五格＆重置牌堆（保留「隨機」模式）
      clearAll(false, true);
      setDrawMode("隨機");

      // 確保有 32 枚完整牌堆
      ensureDeck();

      const order = [1, 2, 3, 4, 5];
      for (const pos of order) {
        const type = drawFromDeck();
        if (!type) { alert("牌堆意外為空，請再試一次。"); ensureDeck(); break; }
        // deck 已保證數量，理論上不會超上限；保險檢查可保留
        if (!canPlace(type, pos)) continue;
        picks[pos] = { type, color: pieceColorOf(type) };
      }

      selectedPos = null; // 抽滿後取消鎖定
      render();
    }


    // ====== 隨機抽 1 枚（若 5 格已滿則提示） ======
    function randomDrawOne() {
      // 若 5 格已滿，直接提示
      const empty = firstEmptyPos();
      if (!empty) { alert("5 格已滿，請先「清除」再抽。"); return; }

      // 定位模式優先：若鎖定的格為空，就放那格；否則放最前面空格
      const target = (selectedPos && !picks[selectedPos]) ? selectedPos : empty;

      // 抽 1 枚；若牌堆空了會自動重建
      setDrawMode("隨機");
      const type = drawFromDeck();
      if (!type) { alert("牌堆已空，已重建。請再試一次。"); ensureDeck(); return; }

      // 放到目標格
      if (!canPlace(type, target)) {
        // 理論上不會發生（因為 5 格上限遠小於整副棋數），但保險處理：
        alert(`「${type}」已超出可用數量，改抽下一枚。`);
        return randomDrawOne(); // 直接再抽一枚
      }
      picks[target] = { type, color: pieceColorOf(type) };

      // 下一個預選目標 = 下一個空格（若已滿則 null）
      selectedPos = firstEmptyPos();
      render();
    }

    // ====== Flex 送出 ======
    function buildFlexMessage() {
      const cells = [1, 2, 3, 4, 5].map(i => picks[i]);
      if (cells.some(x => !x)) { alert("請先選滿 5 格再送出。"); return null; }

      const toText = (cell) => ({
        type: "text",
        text: String(cell.type),
        weight: "bold",
        align: "center",
        size: "xl",
        color: cell.color === "red" ? "#d32f2f" : "#111111"
      });

      const t1 = toText(picks[4]);
      const t2 = toText(picks[2]);
      const t3 = toText(picks[1]);
      const t4 = toText(picks[3]);
      const t5 = toText(picks[5]);

      const summary = [1, 2, 3, 4, 5].map(i => `${i}:${picks[i].type}`).join("  ");
      const fiveStr = [1, 2, 3, 4, 5].map(i => picks[i].type).join(""); // 五字
      const fiveParam = encodeURIComponent(fiveStr);
      const titleText = (titleEl.textContent || "象棋卜卦-單掛").trim();
      const modeTag = (drawMode === "隨機" ? "隨機" : "手動"); // 要顯示的文字
      const modeParam = encodeURIComponent(modeTag);
      const modeHint = (drawMode === "隨機" ? "*隨機抽卦結果僅供參考*" : "");

      // ★ 圓圈尺寸（可調）：建議 72~90px
      const CIRCLE_SIZE = "80px";
      // ★ 文字大小（可調）： xxs / xs / sm / md / lg / xl / xxl / 3xl / 4xl / 5xl
      const PIECE_TEXT_SIZE = "5xl";
      // ★ 舒服背景色（Flex bubble 的 body）
      const FLEX_BG = "#F6F7FB"; // 微藍灰，耐看

      // 產生：黑外圈 + 白內圈 + 中央字
      const toCircle = (cell) => {
        const pieceColor = (cell.color === "red") ? "#d32f2f" : "#111111";
        return {
          type: "box",
          layout: "vertical",
          width: CIRCLE_SIZE,
          height: CIRCLE_SIZE,
          cornerRadius: "999px",
          backgroundColor: "#111111",     // 黑色外圈
          paddingAll: "2px",               // 外圈厚度
          contents: [
            {
              type: "box",
              layout: "vertical",
              width: "100%", height: "100%",
              cornerRadius: "999px",
              backgroundColor: "#FFFFFF",  // 白色內圈
              contents: [
                { type: "filler" },
                {
                  type: "text",
                  text: String(cell.type),
                  weight: "bold",
                  align: "center",
                  size: PIECE_TEXT_SIZE,
                  color: pieceColor
                },
                { type: "filler" }
              ]
            }
          ]
        };
      };

      const circ4 = toCircle(picks[4]);
      const circ2 = toCircle(picks[2]);
      const circ1 = toCircle(picks[1]);
      const circ3 = toCircle(picks[3]);
      const circ5 = toCircle(picks[5]);

      return {
        type: "flex",
        altText: `${summary}`,
        contents: {
          type: "bubble",
          styles: { // ★ 設定柔和的背景色
            body: { backgroundColor: FLEX_BG },
            footer: { backgroundColor: FLEX_BG }
          },
          body: {
            type: "box",
            layout: "vertical",
            spacing: "md",
            contents: [
              { type: "text", text: titleText, weight: "bold", size: "lg", wrap: true },

              // 上：4（置中）
              { type: "box", layout: "horizontal", justifyContent: "center", contents: [circ4] },

              // 中：2 1 3（間距一致）
              { type: "box", layout: "horizontal", spacing: "md", justifyContent: "center", contents: [circ2, circ1, circ3] },

              // 下：5（置中）
              { type: "box", layout: "horizontal", justifyContent: "center", contents: [circ5] },

              { type: "separator", margin: "md" },
              { type: "text", text: APP_VERSION, size: "xs", color: "#9ca3af", align: "end" },
              { type: "text", text: summary, size: "sm", color: "#6b7280", wrap: true },
              { type: "text", text: modeHint, size: "sm", color: "#6b7280", wrap: true },
              { type: "text", text: fiveStr, size: "sm", color: "#6b7280", wrap: true },
              { type: "text", text: fiveParam, size: "sm", color: "#6b7280", wrap: true }
            ]
          },
          footer: {
            type: "box",
            layout: "vertical",
            spacing: "sm",
            contents: [
              { type: "text", text: "Anan Universe Station Generated.", size: "xxs", color: "#9ca3af", align: "end" },
              {
                type: "box",
                layout: "horizontal",   // 改成水平排列
                spacing: "md",          // 按鈕間距
                contents: [
                  {
                    type: "button",
                    style: "primary",
                    flex: 1,
                    action: {
                      type: "postback",
                      label: "療癒分數",
                      data: fiveStr,
                      displayText: "查療癒分數"
                    }
                  },
                  {
                    type: "button",
                    style: "secondary",
                    flex: 1,
                    action: { type: "uri", label: "再一次", uri: `https://liff.line.me/${LIFF_ID}` }
                  }
                ]
              }
            ]
          }
        }
      };
    }

    async function sendResult() {
      const flex = buildFlexMessage();
      if (!flex) return;
      try {
        if (liff?.isInClient?.()) {
          await liff.sendMessages([flex]);
          alert("已送出，返回聊天室"); liff.closeWindow();
        } else if (liff.isApiAvailable('shareTargetPicker')) {
          await liff.shareTargetPicker([flex]);
          alert("已分享");
        } else {
          alert("請在 LINE 內開啟此 LIFF 頁面再送出。");
        }
      } catch (e) {
        const msg = (e?.message || e || '').toString();
        if ((msg.includes('scope') || msg.includes('not in LIFF app scope')) && liff.isApiAvailable('shareTargetPicker')) {
          await liff.shareTargetPicker([flex]);
          alert("尚未授權 chat_message.write，已改用分享送出");
        } else {
          alert("sendMessages 失敗：" + msg);
        }
      }
    }

    // ====== 綁定 UI ======
    $("askBtn").addEventListener("click", promptQuestion);
    $("reloadBtn").addEventListener("click", hardReload);
    $("clearBtn").addEventListener("click", clearAll);
    $("randomBtn").addEventListener("click", randomFillAll);
    $("sendBtn").addEventListener("click", sendResult);

    Object.entries(posEls).forEach(([idx, el]) => {
      el.addEventListener("click", () => setSelected(Number(idx)));
    });

    document.querySelectorAll(".piece-btn").forEach(btn => {
      btn.addEventListener("click", () => addPiece(btn.dataset.piece));
    });

    // ====== 初始化 LIFF ======
    (async () => {
      try {
        statusEl.textContent = "初始化 LIFF…";
        await liff.init({ liffId: LIFF_ID, withLoginOnExternalBrowser: true });
        if (!liff.isLoggedIn()) { statusEl.textContent = "未登入 → 導向登入"; return liff.login(); }
        const profile = await liff.getProfile();
        statusEl.textContent = `Hello, ${profile.displayName} 👋`;
      } catch (err) {
        console.error(err);
        statusEl.textContent = `LIFF 初始化失敗：${err?.message || "unknown"}`;
      }
    })();

    // ====== 初始狀態與版本顯示 ======
    document.getElementById("ver").textContent = APP_VERSION;

    // 初次渲染
    render();
  </script>
</body>

</html>